// ReCrafted © 2016-2017 Always Too Late

#include "SpaceObjectChunk.h"
#include "SpaceObjectOctree.h"
#include "SpaceObjectOctreeNode.h"
#include "SpaceObject.h"
#include "Meshing/MarchingCubes/MCMesher.h"
#include "Game/World/Voxels/VoxelUtils.h"
#include "Graphics/Mesh.h"
#include "Graphics/Rendering.h"

float Planet(const Vector3& origin, const Vector3& position, float radius)
{
	//var local = position - Vector3(radius, radius, radius);
	//var d = Vector3(fabs(local.x), fabs(local.y), fabs(local.z)) - Vector3(radius, radius, radius);
	//var m = max(d.x, max(d.y, d.z)); 
	//return min(m, d.length());

	var height = (position - origin).length();
	return height - radius;
}

uint8_t SpaceObjectChunk::getLodBorders()
{
	/*uint8_t borders = 5;

	if (node->hasNeighLowerLoD(NodeDirection::Front))
		borders |= BORDER_FRONT;

	if (node->hasNeighLowerLoD(NodeDirection::Back))
		borders |= BORDER_BACK;

	if (node->hasNeighLowerLoD(NodeDirection::Left))
		borders |= BORDER_LEFT;

	if (node->hasNeighLowerLoD(NodeDirection::Right))
		borders |= BORDER_RIGHT;

	if (node->hasNeighLowerLoD(NodeDirection::Top))
		borders |= BORDER_TOP;

	if (node->hasNeighLowerLoD(NodeDirection::Back))
		borders |= BORDER_BOTTOM;*/

	//return borders;
	return 0xFF;
}

void SpaceObjectChunk::init(SpaceObjectOctreeNode* node, SpaceObject* spaceObject)
{
	this->spaceObject = spaceObject;
	this->node = node;

	m_chunkNormal = spaceObject->get_position() - node->get_position();
	m_chunkNormal.normalize();
}

void SpaceObjectChunk::generate(IVoxelMesher* mesher)
{
	// WARNING: this function is called on WORKER THREAD!

	m_mesh = Mesh::createMesh();

	// TODO: 'VoxelProcessor'

	// generate voxel data
	var dataSize = ChunkDataSize * ChunkDataSize * ChunkDataSize;
	m_voxelData = new sbyte[dataSize];
	SecureZeroMemory(m_voxelData, dataSize * sizeof(sbyte));

	// temporary, just for testing, this will be generated by VoxelGenerator TODO: VoxelGenerator
	var objectPosition = spaceObject->get_position();
	var objectRadius = 1024.0f - 100.0f;
	var posMod = Vector3::one() * 0.5f * static_cast<float>(node->get_size());
	var nodePosition = node->get_position() - posMod; // lower-left-back corner

	var lod = int(node->get_size() / float(SpaceObjectOctreeNode::MinimumNodeSize));
	var lod_f = static_cast<float>(lod);

	for(auto x = 0; x < ChunkDataSize; x ++)
	{
		for (auto y = 0; y < ChunkDataSize; y++)
		{
			for (auto z = 0; z < ChunkDataSize; z++)
			{
				const var index = INDEX_3D(x, y, z, ChunkDataSize);

				const var offset = Vector3(float(x), float(y), float(z));
				const var position = nodePosition + offset * lod_f;

				var value = Planet(objectPosition, position, objectRadius);
				var byteValue = VOXEL_FROM_FLOAT(value); // convert to voxel data

				m_voxelData[index] = byteValue;
			}
		}
	}

	// get which directions this chunk must get the bordering skirts
	var borders = getLodBorders();

	// generate mesh
	mesher->generate(nodePosition, lod, borders, m_mesh, m_voxelData);
}

void SpaceObjectChunk::upload()
{
	// upload changes
	if(m_mesh && m_mesh->canUpload())
		m_mesh->upload();
}

void SpaceObjectChunk::update()
{
	
}

void SpaceObjectChunk::draw()
{
	if (!m_mesh || !m_mesh->isUploaded())
		return;

	Rendering::getInstance()->setState();

	auto matrix = Matrix::identity();
	Rendering::getInstance()->draw(m_mesh, &matrix);
}

void SpaceObjectChunk::dispose()
{
	SafeDelete(m_voxelData);
	SafeDispose(m_mesh);
}
