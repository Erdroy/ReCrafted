// ReCrafted © 2016-2017 Always Too Late

#include "SpaceObjectChunk.h"
#include "SpaceObjectOctree.h"
#include "SpaceObject.h"
#include "Graphics/DebugDraw.h"

#define INDEX_3D(x, y, z, size) ((x) * (size) * (size) + (y) * (size) + (z)) // TODO: VoxelUtils

float Sphere(Vector3& origin, Vector3& position, float radius)
{
	return (position - origin).length() - radius * radius;
}

void SpaceObjectChunk::init(SpaceObjectOctreeNode* node, SpaceObject* spaceObject)
{
	this->spaceObject = spaceObject;
	this->node = node;

	m_chunkNormal = spaceObject->get_position() - node->get_position();
	m_chunkNormal.normalize();
}

void SpaceObjectChunk::generate()
{
	// TODO: 'VoxelProcessor'

	// generate voxel data
	auto dataSize = ChunkDataSize * ChunkDataSize * ChunkDataSize;
	m_voxelData = new sbyte[dataSize];
	SecureZeroMemory(m_voxelData, dataSize * sizeof(sbyte));

	// temporary, just for testing, this will be generated by VoxelGenerator TODO: VoxelGenerator
	auto objectPosition = spaceObject->get_position();
	auto objectRadius = spaceObject->get_radius() * 0.75f;
	for(auto x = 0; x < ChunkDataSize; x ++)
	{
		for (auto y = 0; y < ChunkDataSize; y++)
		{
			for (auto z = 0; z < ChunkDataSize; z++)
			{
				auto index = INDEX_3D(x, y, z, ChunkDataSize);
				auto position = Vector3(x, y, z);

				m_voxelData[index] = Sphere(objectPosition, position, objectRadius);
			}
		}
	}

	// TODO: generate mesh
}

void SpaceObjectChunk::update()
{
	DebugDraw::setColor(Color(0, 255, 0));
	DebugDraw::drawLine(node->get_position(), node->get_position() + m_chunkNormal * node->get_size() * 0.3f);
	DebugDraw::drawCube(node->get_position() + m_chunkNormal * node->get_size() * 0.3f, Vector3::one());
}

void SpaceObjectChunk::draw()
{

}

void SpaceObjectChunk::dispose()
{
	SafeDelete(m_voxelData);
}
