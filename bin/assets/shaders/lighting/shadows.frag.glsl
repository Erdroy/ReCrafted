// GLSL Fragment Shader "PSMain"
// Generated by XShaderCompiler
// 14/01/2017 22:06:39

#version 330 core

in vec2 xsc_vary_TEXCOORD0;

out float SV_Target0;

vec3 PositionFromDepth(float depth, vec2 vTexCoord, mat4 invProj)
{
    float x = vTexCoord.x * 2.0 - 1.0;
    float y = float((1 - int(vTexCoord.y)) * 2 - 1);
    vec4 vProjectedPos = vec4(x, y, depth, 1.0f);
    vec4 vPositionVS = (vProjectedPos * invProj);
    return vPositionVS.xyz / vPositionVS.w;
}

layout(std140) uniform Data
{
    mat4 g_matInvView;
    mat4 g_matInvProj;
    mat4 g_matLightViewProj;
    vec2 g_vShadowMapSize;
    vec2 g_vOcclusionTextureSize;
};

uniform sampler2D ShadowMap;
uniform sampler2D Depth;

const float BIAS = 0.00056f;

float CalcShadowPCF(float fLightDepth, vec2 vShadowTexCoord)
{
	float fShadowTerm = 0.0f;

	vec2 vShadowMapCoord = g_vShadowMapSize * vShadowTexCoord;
         
	vec2 vLerps = fract(vShadowMapCoord);

	float fSamples[4];
	fSamples[0] = (texture(ShadowMap, vShadowTexCoord).x + BIAS < fLightDepth) ? 0.0f : 1.0f;
	fSamples[1] = (texture(ShadowMap, vShadowTexCoord + vec2(1.0 / g_vShadowMapSize.x, 0)).x + BIAS < fLightDepth) ? 0.0f : 1.0f;
	fSamples[2] = (texture(ShadowMap, vShadowTexCoord + vec2(0, 1.0 / g_vShadowMapSize.y)).x + BIAS < fLightDepth) ? 0.0f : 1.0f;
	fSamples[3] = (texture(ShadowMap, vShadowTexCoord + vec2(1.0 / g_vShadowMapSize.x, 1.0 / g_vShadowMapSize.y)).x + BIAS < fLightDepth) ? 0.0f : 1.0f;

	fShadowTerm = mix(mix(fSamples[0], fSamples[1], vLerps.x), mix(fSamples[2], fSamples[3], vLerps.x), vLerps.y);

	return fShadowTerm;
}

float CalcShadowSoftPCF(float fLightDepth, vec2 vShadowTexCoord, int iSqrtSamples)
{
    float fShadowTerm = 0.0f;
    float fRadius = float((iSqrtSamples - 1) / 2);
    float fWeightAccum = 0.0f;
    for (float y = -fRadius; y <= fRadius; y++)
    {
        for (float x = -fRadius; x <= fRadius; x++)
        {
            vec2 vOffset = vec2(0);
            vOffset = vec2(x, y);
            vOffset /= g_vShadowMapSize;
            vec2 vSamplePoint = vShadowTexCoord + vOffset;
            float fDepth = texture(ShadowMap, vSamplePoint).x;
            float fSample = (fLightDepth <= fDepth + BIAS) ? 1 : 0; // <----
            float xWeight = 1.0;
            float yWeight = 1.0;
            if (x == -fRadius)
                xWeight = float(1 - int(fract(vShadowTexCoord.x * g_vShadowMapSize.x)));
            else if (x == fRadius)
                xWeight = fract(vShadowTexCoord.x * g_vShadowMapSize.x);
            if (y == -fRadius)
                yWeight = float(1 - int(fract(vShadowTexCoord.y * g_vShadowMapSize.y)));
            else if (y == fRadius)
                yWeight = fract(vShadowTexCoord.y * g_vShadowMapSize.y);
            fShadowTerm += fSample * xWeight * yWeight;
            fWeightAccum = xWeight * yWeight;
        }
    }
    fShadowTerm /= float((iSqrtSamples * iSqrtSamples));
    fShadowTerm *= 1.55f;
    return fShadowTerm;
}

void main()
{
	vec2 uv = xsc_vary_TEXCOORD0;
	uv.y = -uv.y;

    float depth = texture(Depth, uv).r;
    vec4 vPositionVS = vec4(PositionFromDepth(depth, uv, g_matInvProj), 1.0f);
    if (depth >= 0.99999f)
    {
        SV_Target0 = 1.0f;
        return;
    }
    mat4 matViewToLightViewProj = (g_matInvView * g_matLightViewProj);
    vec4 vPositionLightCS = (vPositionVS * matViewToLightViewProj);
    float fLightDepth = vPositionLightCS.z / vPositionLightCS.w;
    vec2 vShadowTexCoord = 0.5 * vPositionLightCS.xy / vPositionLightCS.w + vec2(0.5f, 0.5f);
    vShadowTexCoord.y = 1.0f - vShadowTexCoord.y;
    vShadowTexCoord += (0.5f / g_vShadowMapSize);
	SV_Target0 = vPositionLightCS.x;//CalcShadowSoftPCF(fLightDepth, vShadowTexCoord, 3);
}

